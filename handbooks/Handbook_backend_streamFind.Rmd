---
title: "Handbook streamFind: back end"
author: "Ricardo Cunha"
output:
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    theme: paper
    css: "Handbook_backend_streamFind.css"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", fig.width = 9, cache = TRUE)
```

<br> <br>

------------------------------------------------------------------------

```{r libraries, include=FALSE, cache=FALSE}
library(knitr)
library(kableExtra)
library(magrittr)
library(ggplot2)
library(plotly)
library(streamFind)
```

```{r libraries-dev, eval=FALSE, include=FALSE, cache=FALSE}
#for development only
library(data.table)
library(xml2)
library(checkmate)
library(stringr)
library(tools)
library(dplyr)
library(xcms)
library(patRoon)
```

# Objective

The streamFind project entitled "Flexible data analysis and workflow designer to identify chemicals in the water cycle" is funded by the [Bundesministerium für Bildung und Forschung (BMBF)](https://www.bmbf.de) and is a cooperation between the [Institut für Energie- und Umwelttechnik e. V. (IUTA)](https://www.iuta.de) and [Forschungszentrum Informatik (FZI)](https://www.fzi.de/). The major focus of streamFind is data processing for environmental and quality studies. The streamFind package aims to stimulate the use of advanced data analysis (e.g., non-target screening, statistical analysis, etc.) in routine studies, promoting standardization of data processing and structure and easing the retrospective evaluation of data. The streamFind package can be used by academics but also by technicians due to the comprehensive documentation and well categorized set of integrated functionalities or modules (see handbooks folder for more information).

This handbook focuses on describing and demonstrating the R package streamFind which aims to be a tool set for processing of MS, Raman, UV and other types of data.

# Install

For installation of the streamFind package, it is recommended to firstly ensure that the dependencies are currently installed. Several existing R packages and external functionalities are used in streamFind for various processing steps. A major dependency of streamFind is the [patRoon](https://github.com/rickhelmus/patRoon) R package. The patRoon package combines several functionalities for basic and advanced data processing and can be used interchangeably with streamFind.

### Install dependencies

#### R and RTools
 
[R](https://cran.r-project.org/) and [RTools](https://cran.r-project.org/bin/windows/Rtools/) for Windows users. The `r R.version.string` can be obtained in https://cran.r-project.org/. The RTools can be downloaded in https://cran.r-project.org/bin/windows/Rtools/. Make sure to download the right version for the R version installed. Installation instructions are given in both sources.

#### patRoon

The patRoon's [handbook](https://rickhelmus.github.io/patRoon/handbook_bd/manual-installation.html#r-prerequisites) offers detailed information on how to install the [patRoon](https://github.com/rickhelmus/patRoon) R package and the required [dependencies](https://rickhelmus.github.io/patRoon/handbook_bd/manual-installation.html#other-dependencies).

### Install streamFind

The [streamFind](https://github.com/ricardobachertdacunha/streamFind) R package can be installed from the GitHub repository with the following code line:

```{r install-streamfind, eval=FALSE}
remotes::install_github("ricardobachertdacunha/streamFind", dependencies = TRUE)
```
 
## Docker image

Not yet available.

# Resources

## Files

The streamFind package includes example data files via the [streamFindData R package](https://github.com/ricardobachertdacunha/streamFindData). Once installed the full file paths of MS data files can be obtained as shown below. Alternatively, the files can be obtained directly from folder `system.file(package = "streamFindData", dir = "extdata")`. The files available are described in Table \@ref(tab:description-files). Note, the MS files (.mzML) were trimmed with the function `trimSpectraFilesMZR` to reduce their size. The centroided Agilent Q-TOF files were trimmed with retention time between 900 and 1350 seconds, *m/z* for MS1 data between 200 and 450 Da and *m/z* for MS2 between 35 and 450 Da. Additionally, MS1 and MS2 traces below 100 and 50 counts were removed, respectively. The profile Agilent Q-TOF files were trimmed with retention time between 1000 and 1200 seconds, *m/z* for MS1 data between 200 and 300 Da and *m/z* for MS2 between 35 and 300 Da. Additionally, MS1 and MS2 traces below 1 count were removed to exclude empty spectra. The files are used within the document for demonstration of the back end.

```{r resource-files, cache=FALSE}
files <- streamFindData::msFilePaths()
```

```{r description-files, echo=FALSE}
df_files_desc <- streamFindData::msFilesDescription()

knitr::kable(df_files_desc, caption = "Files included in the streamFind package.") %>%
  column_spec(column = 3, width = "100px") %>%
  column_spec(column = 4, width = "60px") %>%
  kable_styling(font_size = 11.5, bootstrap_options = c("striped", "hover", "responsive"), fixed_thead = TRUE) %>%
  scroll_box(width = "100%", height = "600px")
```

## Spiked chemicals

The chemicals spiked in the files are described below in Table \@ref(tab:show-table-chemicals). The internal standards (IS) are spiked to all Agilent Q-TOF files. The chemical standards (S) were only spiked for the first 6 Agilent Q-TOF files not to the blanks nor wastewater analysis files. Note that not all IS and S are visible in the profile Agilent Q-TOF files as a narrower trimming was applied.

```{r load-table-chemicals}
db <- streamFindData::msSpikedChemicals()
```

```{r show-table-chemicals, echo=FALSE}
knitr::kable(db[, .(name, CAS, formula, mass, rt, ionization, tag, in_file)], caption = "Chemical standards spiked.") %>%
  kable_styling(font_size = 11, bootstrap_options = c("striped", "hover", "responsive"), fixed_thead = TRUE) %>%
  scroll_box(width = "100%", height = "600px")
```

# Objects

The streamFind package uses S4 class objects (e.g., *streamSet*, *msData*, *msAnalysis*, etc.) for structuring data. The S4 classes and their main getter and setter methods are presented and exemplified in this section. An overview of the S4 classes and their hierarchy is presented in Figure \@ref(fig:classes-overview) using MS analyses as an example. Other data types, such as from UV and Raman analyses, would lead to different classes (e.g., *uvData* and *uvAnalysis* and *ramanData* and *ramanAnalysis*, respectively) but the hierarchy is similar as shown for MS data (not yet implemented).

```{r classes-overview, echo=FALSE, fig.cap="Overview of the S4 classes and their hierarchy with emphasis on MS analyses.", out.width="100%"}
knitr::include_graphics(paste0(getwd(), "/hb_backend_figures/classes_overview.png"))
```

## streamSet class

The set creation is demonstrated below for the three MS files (triplicate, 1 to 3 in \@ref(tab:description-files)) where a set of chemicals were spiked (see \@ref(spiked-chemicals) with tag IS and S). The initial S4 class created in the `newStreamSet` function is *streamSet*. The subclass is then defined according to the type of files added. Note that multiple file types are not possible as a subclass cannot be defined.

```{r newstreamset-call, message=FALSE, results='hide', message=FALSE, warning=FALSE}
#New streamSet with the files 1 to 3
sp1 <- newStreamSet(files = files[1:3], title = "Example_01")
```

## msData class

Because the added files were all with mzML format (i.e., MS files), the subclass of `sp1` is directly defined as *msData*. The structure for further processing data is then set for MS data. Other data formats/structure will lead to different sub classes (e.g., *uvData* and *ramanData*) but is not yet implemented within the streamFind package.

```{r msdata_streamset_classes}
is(sp1)
```

The *msData* structure includes the *streamSet* class plus the `features` slot. The title and date slots correspond to the set title and creation date, respectively. The analyses slot is a list with a *msAnalysis* S4 class object per MS file added. The `features` slot is a *msFeatures* S4 class object to hold the results from alignment, grouping (or correspondence) and annotation of peaks across analyses. Further information for *msAnalysis* is given in the next sub-chapter (\@ref(msanalysis-class)) and for *msFeatures* is given in the sub-chapter \@ref(msfeatures-class), after creation of features by performing correspondence of peaks across analyses.

-   *msData* structure:

```{r structure_msdata}
str(sp1, max.level = 2)
```

## msAnalysis class

The *msAnalysis* class is structured as shown below. Note that the S4 method `getAnalyses` for *msData* was used to obtain the *msAnalysis* of the first analysis as defined by the second argument. In general, access to raw data (i.e., traces and chromatograms) as well as respective plotting S4 methods can be applied to both the *msAnalysis* and *msData* (as described in \@ref(accessing-raw-data)).

The slot analysis corresponds to the analysis name. The metadata slot is a list of objects with informative entries of the analysis file. The metadata list can be expanded with additional information about the analysis/sample (e.g., sample location, weather conditions, process sensor data, etc.). The slot settings is used to store processing steps (e.g., peak picking) as *settings* S4 class objects, including the processing step name/ID, the algorithm used and the respective processing parameters applied. The settings can be used for history track but also for re-run the processing steps when required. The spectra and chromatograms slots are used to store low level data (i.e., mass traces either in profile or centroided modes) from the MS files. Finally, the peaks slot is used to store the chromatographic peaks after peak picking. As no other processing step was applied the spectra, chromatograms and peaks in the *msAnalysis* are empty `data.tables` for now.

-   *msAnalysis* structure:

```{r msanalysis_structure}
a1 <- getAnalyses(sp1, 1)
str(a1, max.level = 2)
```

### Create an msAnalysis

An *msAnalysis* object can be created without the need of running `newStreamSet`. The method `newAnalysis` can be used for initiating the *msAnalysis* when a full path of an MS file (i.e., with extension mzML or other MS format) is given. Similar to `newStreamSet`, the format of the file given as file argument dictates the class of the analysis object returned from the `newAnalysis` function.

```{r create-msanalysis, message=FALSE, results='hide'}
#creating an msAnalysis object for the 4th file, corresponding to profile MS data
aProf <- newAnalysis(file = files[7])
```

```{r create-msanalysis-show}
aProf
```

### Add msAnalysis to msData

As the method `getAnalysis` can be used to obtain an *msAnalysis* from an *msData* object, the method `addAnalyses` is used to add extra *msAnalysis* objects to *msData*. Below the files 7 to 9 are added to the already created *msData* (containing files 1 to 3). Note that both `getAnalyses` and `addAnalyses` can be applied to equivalent classes to *msData* (i.e., *uvData* and *ramanData*). Also, note that when adding analyses to an *msData* object with features (i.e., with peaks grouped across analyses), the *msFeatures* content is cleared as the grouping is invalidated with new *msAnalysis* objects.

```{r add-msanalysis}

#all profile MS files
aProfs <- lapply(files[7:9], function(x) newAnalysis(x))

#adding the profile analyses to msData
sp1 <- addAnalyses(sp1, analysisList = aProfs)

#show added files in msData
sp1
```

### Handle metadata

#### Get metadata

Below, the `getMetadata` S4 method of *msData* is used to display the metadata. Note, `getMetadata` also works for *msAnalysis* S4 class as shown below.

-   get metadata:

```{r metadata_structure}
#metadata of the fourth analyses in the msData
getMetadata(sp1, analyses = 4)

#applied directly to the msAnalysis S4 class
getMetadata(a1)
```

#### Add metadata

Additional metadata can be added with the `addMetadata` method for both *msAnalysis* and *msData*. Note that for *msData* the metadata input needs to be a list of vectors with the same length as the number of analyses or a data.frame/data.table with the number of rows as the nmumber of analyses, as shown below.

-   add metadata to an *msAnalysis* object (a1):

```{r add-metadata-msanalysis}
#as a named vector
meta_vec <- c("water_as_vec", TRUE)
names(meta_vec) <- c("matrix", "spiked")

a1 <- addMetadata(a1, metadata = meta_vec)

getMetadata(a1, which = names(meta_vec))

#as data.frame (would also work with data.table)
meta_df <- data.frame(matrix = "water_as_df", spiked = TRUE)

#add overwrite to TRUE, as the metadata name is already in the msAnalysis
a1 <- addMetadata(a1, metadata = meta_df, overwrite = TRUE)

getMetadata(a1, which = names(meta_vec))
```

-   add metadata to an *msData* object (sp1):

```{r add-metadata-msdata}
#as a named vector
meta_1 <- c("water", TRUE, "centroid")
names(meta_1) <- c("matrix", "spiked", "datatype")

meta_2 <- c("water", TRUE, "profile")
names(meta_2) <- c("matrix", "spiked", "datatype")

meta_vec_list <- c(rep(list(meta_1), 3), rep(list(meta_2), 3))

#optional, but when numbered list the order is taken as is
names(meta_vec_list) <- analysisNames(sp1)

sp1 <- addMetadata(sp1, metadata = meta_vec_list)

getMetadata(sp1, which = names(meta_1))

#as a data.frame (would also work with data.table)
meta_df_2 <- data.frame(
  analysis = analysisNames(sp1),
  matrix = rep("water_as_df", 6),
  spiked = rep(TRUE, 6),
  datatype = c(rep("centroid", 3), rep("profile", 3))
)

# Note, the analysis column doesn't need to be added
# but the order of the rows will be used as is.
# when names of the analyses are in analysis column
# that order is taken to match the analysis in the msData object.

#add overwrite to TRUE, as the metadata name is already in the analyses of msData
sp1 <- addMetadata(sp1, metadata = meta_df_2, overwrite = TRUE)

getMetadata(sp1, analyses = c(3, 4), which = names(meta_1))
```

# Accessing raw data

The tools for raw data access and plotting (i.e., spectra and chromatograms) share a target search approach. The data search is based on pre-defined time and mass (inc. *m/z*) targets. For traces (i.e., raw MS mass traces), time (in seconds) and *m/z* (in Da) ranges are given for accessing and plotting. Access to mass traces is relevant for further development of data processing steps/functions and for visualization of raw data, easing the evaluation of processing steps (e.g., peaks wrongly not found during peak picking).

## Defining targets

As aforementioned, access to raw data is based on defining *m/z* and retention time targets. The function `makeTargets` is used for comprehensively build targets. As shown below for Carbamazepin-d10 and Diuron-d6, multiple ways can be used to assemble targets but similarly returning a uniform `data.table` class object with a target list. Accessing and plotting S4 methods in streamFind use the `makeTargets` function to collect raw data from the analysis files. Therefore, the arguments `mz`, `rt`, `ppm`, `sec` and `id` are present in most S4 methods for accessing and plotting data as demonstrated in the following sections.

```{r carb-diu}
#Carbamazepin-d10 is ionized only in positive mode
carbamazepin_d10 <- db[name %in% "Carbamazepin-d10", .(name, mass, rt)]
carbamazepin_d10

#Diuron-d6 is ionized in both positive and negative modes
diuron_d6 <- db[name %in% "Diuron-d6", .(name, mass, rt)]
diuron_d6
```

```{r make_targets}
carb_pos <- carbamazepin_d10$mass + 1.0073
carb_rt <- carbamazepin_d10$rt
diu_pos <- diuron_d6$mass + 1.0073
diu_rt <- diuron_d6$rt

sec_dev <- 30 #seconds
ppm_dev <- 20

#case 1
mz1 <- c(carb_pos, diu_pos)
rt1 <- c(carb_rt, diu_rt)
id1 <- c("target1", "target2")
targets1 <- makeTargets(mz = mz1, rt = rt1, ppm = ppm_dev, sec = sec_dev, id = id1)

targets1

#case 2
ppm_carb <- ppm_dev / 1E6 * carb_pos
ppm_diu <- ppm_dev / 1E6 * diu_pos

mz2 <- data.frame(mzmin = c(carb_pos - ppm_carb, diu_pos - ppm_diu),
                  mzmax = c(carb_pos + ppm_carb, diu_pos + ppm_diu))

rt2 <- data.frame(rtmin = c(carb_rt - sec_dev, diu_rt - sec_dev),
                  rtmax = c(carb_rt + sec_dev, diu_rt + sec_dev))

targets2 <- makeTargets(mz = mz2, rt = rt2)
targets2

#case 3
mz3 <- data.frame(
  id = c("target1", "target2"),
  mz = c(carb_pos, diu_pos),
  rt = c(carb_rt, diu_rt)
)

targets3 <- makeTargets(mz = mz3, ppm = ppm_dev, sec = sec_dev)
targets3

#case 4
mz4 <- data.frame(
  id = c("target1", "target2"),
  mzmin = c(carb_pos - ppm_carb, diu_pos - ppm_diu),
  mzmax = c(carb_pos + ppm_carb, diu_pos + ppm_diu),
  rtmin = c(carb_rt - sec_dev, diu_rt - sec_dev),
  rtmax = c(carb_rt + sec_dev, diu_rt + sec_dev)
)

targets4 <- makeTargets(mz = mz4)
targets4
```

```{r test-targets}
#test all equal target 1
t1 <- rbind(targets1[1, ], targets2[1,], targets3[1, ], targets4[1, ])
all(round(apply(t1[, 2:7], 2, sd), digits = 4) == 0) 

#test all equal target 2
t2 <- rbind(targets1[2, ], targets2[2,], targets3[2, ], targets4[2, ])
all(round(apply(t2[, 2:7], 2, sd), digits = 4) == 0)
```

## EICs

Extracted ion chromatograms (EICs) are obtained either from loaded spectra in the *msData* or *msAnalysis* objects or from querying traces directly in the raw data file (mzML or mzXML). The latter is less disk memory intense as data is loaded from raw files on demand. The S4 method `EICs` is used to extract MS1 data from raw data files.

```{r eics-method}
#EIC of targets from first analysis using msAnalysis class
eic1 <- EICs(a1, mz = targets4)
head(eic1, 6)
```

```{r eics-method-2}
#EIC of targets from analyses 1 to 3 using msData class
eic2 <- EICs(sp1, analyses = 1:3, mz = targets4)
head(eic2, 6)
```

The obtained EICs can be plotted with `plotEICs` S4 method, as shown below. The object for `plotEICs` can be a `data.table` as resulting from the `EICs` method or the actual *msData* or *msAnalysis* objects, using the same arguments as in `EICs` for collecting the data (i.e., to define the targets).

```{r ploteics-static}
#plot the produced EIC data.table
plotEICs(eic1)
```

```{r ploteics-interactive}
#using the msData class object and targets but with interactive plot
plotEICs(sp1, analyses = 1:3, mz = targets4, colorBy = "analyses", interactive = TRUE)
```

```{r ploteics-interactive-2}
#using msAnalysis
plotEICs(a1, mz = targets4, interactive = TRUE)
```

```{r ploteics-interactive-3}
#using msData centroid (file 3) vs profile (file 4); note that the higher intensity for profile data is due to the sum of the traces within the same spectrum (i.e., with the same retention time)
plotEICs(sp1, analyses = 3:4, mz = targets3, colorBy = "replicates", interactive = TRUE)
```

## TICs and BPCs

Total ion chromatograms (TICs) and base peak chromatograms (BPCs) are obtained either by pre-loading and adding the chromatogram data to the *msAnalysis*, extracting the data in a `TICs` call (S4 method) or loading all spectra and applying the sum of intensities to each spectrum. Note, TIC is already available as chromatogram in mzML data from the major HRMS vendors. The S4 method TICs first evaluates if the TIC chromatogram is available in the mzML and when not, the spectra data is extracted and used instead.

```{r tics_method}
# TIC for both analyses in the msData class object
tic1 <- TICs(sp1, analyses = 1:3)
head(tic1, 6)
```

```{r tics_method-2}
#TIC of the msAnalysis object
head(TIC(a1), 6)
```

```{r bpc_method}
#BPC of the msAnalysis object
head(BPC(a1), 6)
```

Similarly to EICs, the TICs and BPCs can be plotted with `plotTICs` and `plotBPCs` S4 methods, respectively, as shown below.

```{r plotticss-method}
#using a data.table as obatined by TICs
plotTICs(tic1, interactive = TRUE)
```

```{r plotticss-method-2}
#using the msData object
plotTICs(sp1, analyses = 1:3, colorBy = "replicates")
```

```{r plotbpcss-method-2}
#using the msData object
plotBPCs(sp1, colorBy = "replicates")
```

```{r plotticss-method-3}
#using the msAnalysis
plotTICs(a1)
```

## XICs

A more informative method of obtaining EICs is via the method `XICs` which extract a the three dimensional (*m/Z*, rt and intensity) chromatograms from given targets. In the example below, the *m/z* dimension is also included in the resulting table to improve inspection of traces.

```{r xics-method}
#using the msData class object for second target with wide ppm range
xic1 <- XICs(sp1, analyses = 3:4, mz = mz1[2], rt = rt1[2], ppm = 500, sec = 30)
xic1
```

```{r xics-method-2}
#with a msAnalysis class object for targets in data.frame
xic2 <- XICs(a1, mz = targets4)
head(xic2, 3)
```

Similarly, the XICs can be plotted with the S4 method `plotXICs`, as shown below. Other arguments are available for plotting `XICs`, including a target area for the expected targets. As shown in the plot below, the red mark is defined by the arguments `targetsMark` (a table with columns mz and rt to define the expected *m/z* and retention times) and `ppmMark` and `secMark` to define the mass (in ppm) and time (in seconds) range of the target squares. The `numberRows` is used to control the number of rows of the grouped plot. The concept for the XIC plot is adapted from the R package [MSnbase](https://bioconductor.org/packages/release/bioc/html/MSnbase.html).

```{r plotxics-method}
#using the output of XICs S4 method (a data.table) for plotting centroided and profile data
plotXICs(xic1, legendNames = c("target number 1", "target number 2"), plotTargetMark = TRUE,
 targetsMark = targets4[, c("mz", "rt")], ppmMark = 5, secMark = 10, numberRows = 2)
```

```{r plotxics-method-2}
#using the msData class and plotting the first target from the first analysis
plotXICs(sp1[1], mz = targets4[1, ])
```

```{r plotxics-method-3}
#for the msAnalysis, the second target with wide m/z and rt ranges
plotXICs(a1, mz = mz1[2], rt = rt1[2], ppm = 50, sec = 120)
```

# Loading raw data

The S4 methods applied above parse the data from the raw data files which is less disk memory intense but slower. Alternatively, the raw data can be loaded to (each) *msAnalysis* and from their is faster available. However, when loaded, the raw data has a higher memory footprint. Therefore, the data can be optionally loaded and stored as a simple *data.table* in the respective *msAnalysis* (other classes of the same level might have the raw data directly loaded if the data has a lower memory footprint). Below we demonstrate how to load (via `loadRawData` S4 method) and access (via `spectra` or `chromatograms`) the raw spectra and chromatograms from an *msAnalaysis* and *msData* object. Both S4 methods (`spectra` or `chromatograms`) return a *data.table* where further operations can be applied to subset the data, as demonstrated below. The standard *data.table* operations can be applied, see documentation in <https://cran.r-project.org/web/packages/data.table/> for more information and code examples/instructions. A cheat sheet for *data.table* operations can be downloaded in <https://raw.githubusercontent.com/rstudio/cheatsheets/main/datatable.pdf>. In streamFind, the *data.table* is always the preferred format for table objects.

```{r loadrawdata-msanalysis}
#load raw data to an msAnalysis object
a1 <- loadRawData(a1)
```

```{r loadrawdata-msanalysis-show}
a1
```

```{r loadrawdata-msdata}
#load raw data to the first three samples in an msData object.
sp1 <- loadRawData(sp1)
```

```{r loadrawdata-msdata-show}
sp1
```

## Spectra

Spectra can be accessed from an *msAnalaysis* or *msData* as shown below with methods `spectra`. The method `plotSpectra` is also available for both classes.

```{r spectra-msanalysis}
#example of accessing the six most intense fragments of the first target with msAnalysis
s_data <- spectra(a1)
s_data <- s_data[preMZ >= targets4$mzmin[1] & preMZ <= targets4$mzmax[1], ]
s_data <- s_data[rt >= targets4$rtmin[1] & rt <= targets4$rtmax[1], ]
s_data <- s_data[order(intensity, decreasing = TRUE), ]
s_data[1:6, ]
```

```{r spectra-msdata}
#example of accessing the two most intense fragments of the first target with msData
s_data_2 <- spectra(sp1)
s_data_2 <- s_data_2[preMZ >= targets4$mzmin[1] & preMZ <= targets4$mzmax[1], ]
s_data_2 <- s_data_2[rt >= targets4$rtmin[1] & rt <= targets4$rtmax[1], ]
s_data_2 <- s_data_2[order(intensity, decreasing = TRUE), ]
s_data_2[1:4, ]
```

```{r plot-spectra-msanalysis}
# plotting spectra of isotopic pattern for Diuron-d6 in an msAnalysis
plotSpectra(a1, mz = data.frame(mzmin = 238, mzmax = 250,
                                rtmin = 1145, rtmax = 1170))
```

## Chromatograms

Chromatograms can be included in mzML files. For instance, TIC is often available as chromatogram in mzML files. Also, analyses produced in multiple reaction monitoring (MRM) mode, when exported to mzML without collapsing the MRMs, will have the data stored as chromatograms, as shown below. The method `chromatograms` 

```{r create-mrm-msAnalysis}
# MS files acquired in MRM
mrm <- newAnalysis(file = files[29])

# data only as chromatograms
mrm
```

```{r laod-show-chromatograms}
# loading raw data into the msAnalysis
mrm <- loadRawData(mrm)

# getting the chromatograms as data.table
chroms <- chromatograms(mrm)

head(chroms)
```

```{r plot-loaded-chromatograms}
# plotting the second and third chromatograms in the msAnalysis
plotChromatograms(mrm, index = c(2,3), interactive = TRUE)
```


# Converting raw data

Regarding MS data, the format used in streamFind is mzML or mzXML either centroid or profile mode. However, both mentioned formats do not correspond to the formats of actual MS system vendors. [msConvert](https://proteowizard.sourceforge.io/download.html) from [ProteoWizard](https://proteowizard.sourceforge.io/) can be used to convert the main MS formats (and others) to mzML (preferable as it is the most recent) or mzXML, including data centroiding when required. The msConvert GUI tool can be used for conversion. However, if automation is required, the [command line](https://proteowizard.sourceforge.io/tools/msconvert.html) of msConvert is used within the function `convertFiles` in streamFind, as shown below. The function `compatibleFileFormatsForConversion()` can be used to check which vendor formats are currently possible to convert in the streamFind through ProteoWizard.

```{r compatible-vendor-formats, echo=FALSE}
vfor <- streamFind::compatibleFileFormatsForConversion()
knitr::kable(vfor, caption = "Vendor formats possible to be converted to mzML/mzXML.") %>%
  kable_styling(font_size = 11, bootstrap_options = c("striped", "hover", "responsive"), fixed_thead = TRUE) %>%
  scroll_box(width = "100%", height = "300px")
```

```{r converting-raw-data, eval = FALSE}
##Not run

#vector with full paths to vendor files
file <- full_path_to_vendor_file/s

#option to perform centroiding of MS1 and MS2 data
opts_list <- list(filter = "peakPicking vendor msLevel=1-2")

#convert the file
convertFiles(file, type = "ms", outfile = "mzML", outdir = NULL, opts_list = opts_list)

#Note, when outdir is NULL the directory of the original file will be used for the new file.
```

# Basic workflow

The basic workflow (Figure \@ref(fig:workflow-scheme) left column) includes the following steps: (1) set creation, (2) data conversion (when required/applicable), (3) assignment of analysis replicate names and respective blank analysis replicates, (4) peak finding (or peak picking), (5) peak alignment and grouping into features across analyses, (6) filling of peaks missing in features, (7) annotation of isotopic and adduct features and (8) feature quality evaluation and (9) filtering. The usage of the S4 class objects within the basic workflow (pre-processing) for HRMS data is presented in this section with examples. The right column in Figure \@ref(fig:workflow-scheme illustrates the implementation of modular functionalities for assembly of data processing workflows. The back end for modular assembly and framework of workflows in streamFind is described and demonstrated in section \@ref(workflows).

```{r workflow-scheme, echo=FALSE, fig.cap="Basic workflow scheme."}
knitr::include_graphics(paste0(getwd(), "/hb_backend_figures/workflow_scheme.png"))
```

## Creation of analysis set

The analysis set creation is demonstrated below for twelve HRMS data files corresponding to blank and wastewater (influent) samples, both measured in triplicate and in positive and negative modes. The argument `files` is the main input and can either be a vector of full path files, a table with file (i.e., full file path), replicate (i.e., the name of the analysis replicate group for each file) and blank (i.e., the name of the associated blank analysis replicate group for each file), or the `analysisInfo` data.frame from the package [patRoon](https://github.com/rickhelmus/patRoon). Setting `run_parallel` to `TRUE` will enable parallel processing, which can be useful for large number of files. See more details about parallel processing in the section \@ref(parallel-processing).

```{r newstreamset-basicworkflow, message=FALSE, results='hide', warning=FALSE}
sp2 <- newStreamSet(files = files[10:21],
                    title = "Project Example",
                    run_parallel = TRUE)
```

```{r newstreamset-object-show}
sp2
```

## Manage analyses

Before preforming data processing, the analysis replicate names and associated blank replicate names as well as metadata can be amended/extended.

### Assign replicate names

An essential aspect of environmental analysis is to operate with sample/analysis replicates. The replicates in *msData* can be obtained by the `replicateNames` S4 method as shown below. The setter (assignment) for the replicate names is demonstrated below with the method `replicateNames<-` that takes a vector of character strings with the same length as the number of analyses in a *msData* object. Alternatively, a table with a replicate character column or a character vector can be given in the files or replicates arguments, respectively. Note that *msAnalysis* doesn't contain information about replicate correspondence. The correspondence between analyses is storage in the *msFeatures* within the *msData*.

```{r assign-replicatenames}
#getter for replicate names in msData
replicateNames(sp2)

#setter for replicate names in msData
replicateNames(sp2) <- c(
  rep("blank_neg", 3),
  rep("blank_pos", 3),
  rep("influent_neg", 3),
  rep("influent_pos", 3)
)

replicateNames(sp2)
```

### Assign blankReplicateNames

The blank subtraction is another crucial aspect in environmental analysis. The getter and setter for blank subtraction works the same way as replicates. See examples below. The blank analysis replicate is then assign to the respective analysis. In the example, the first replicate group is assign to the influent samples. Note that the blank will also be assigned to itself. Although not shown, different blank analysis replicates can be assigned to different analysis. The blank subtraction (\@ref(filter-functions)) is then applied per analysis replicate considering the assigned blank replicate. For cross project analysis, a subset of the analyses (*msAnalysis* objects) in a given *msData* can be concatenated to another *msData*, carrying the assigned blank replicate for each analysis as well as all the other analysis information.

`r # TODO add concatenation for msData objects`

```{r assign-blankreplicatenames}
#getter for blank replicates in each sample in a msData object
blankReplicateNames(sp2)

#setter for the blank analysis replicate of msData object
blankReplicateNames(sp2) <- c(
  rep("blank_neg", 3),
  rep("blank_pos", 3),
  rep("blank_neg", 3),
  rep("blank_pos", 3)
)

blankReplicateNames(sp2)
```

### Other getter S4 methods

```{r other-s4methods}
#getter for the analysis table
analysisTable(sp2)

#getter for analysis names in msdata
analysisNames(sp2)

#getter for polarity of analyses in a msData
polarities(sp2)

#sub-setting an msData with `[`-method for the blank analyses
sp2[1:3]
```

## Peak picking

An initial processing step of the basic workflow is the peak picking. Other processing steps might be necessary prior the pick picking, such as data conversion, data centroiding, data calibration, etc. but are not yet implemented in streamFind. The peak picking and other basic processing steps in streamFind are applied through [patRoon](https://github.com/rickhelmus/patRoon). Both *msData* and *msAnalyses* can be converted to native [patRoon](https://github.com/rickhelmus/patRoon) objects for native use of [patRoon](https://github.com/rickhelmus/patRoon). See section \@ref(patRoon-interchangeability) for more information.

`r # TODO create as.msData and as.msAnalysis methods for patRoon's features/featureGroups`

### Processing parameters

For each processing step, settings are often used. In streamFind, the settings used for a given processing step are added/stored as *settings* S4 class objects. Each *settings* object contains the function call name, the algorithm and list of parameters with the respective values. The example below demonstrates the workflow to perform peak picking either by adding the settings during the call for `peakPicking` or by initially add the settings to each *msAnalysis* and then run the `peakPicking`, which looks for the settings in each *msAnalysis*. If different settings are applied among the *msAnalysis* objects, these are used. This means that different algorithms and/or processing parameters can be applied within the same function call. If settings are added during the function call but they already exist in the *msAnalysis*, these are overwritten by the settings used in the function call.

### Create and add parameters

The function `createSettings` is use to assemble the *settings* object, as shown below. Then, the `addSettings` method is used to either add parameters to each analysis in a *msData* object or directly to a *msAnalysis* object. The `getSettings` can be used to check which settings exist in the *msData* and/or *msAnalysis*.

```{r create-processing-parameters}
sp2_pp <- sp2

param <- xcms::CentWaveParam(
  ppm = 12, peakwidth = c(5, 40),
  snthresh = 5, prefilter = c(4, 800),
  mzCenterFun = "mean", integrate = 2,
  mzdiff = -0.0001, fitgauss = TRUE,
  noise = 250, verboseColumns = TRUE,
  firstBaselineCheck = FALSE,
  extendLengthMSW = TRUE
)

#creating the settings S4 class for peak picking
settings_pp <- createSettings(
  call = "peakPicking",
  algorithm = "xcms3",
  parameters = param
)

# the class of settings 
is(settings_pp)


# add the settings to all analyses in msData
sp2_pp <- addSettings(sp2_pp, settings = settings_pp, where = "analyses")

# get the parameters in the third analysis of the msData object
getSettings(sp2_pp, where = "analyses", analyses = 3)

#get msAnalysis
a2 <- getAnalyses(sp2, analyses = 4)

# add the settings to the msAnalysis object
a2 <- addSettings(a2, settings = settings_pp)

# get the parameters of the msAnalysis object
getSettings(a2, call = "peakPicking")
```

### Processing peak picking

```{r peakpicking-msdata-run, results='hide', message=FALSE, warning=FALSE}
#peak picking call using the stored parameters
sp2_pp <- peakPicking(sp2_pp)
```

```{r peakpicking-msdata-show}
# peaks added for each analysis, as shown by column peaks of show method (below)
sp2_pp
```

```{r peakpicking-msdata-run2, results='hide', message=FALSE}
#alternatively, parameters can be added during the function call
sp2_pp_2 <- peakPicking(sp2, settings = settings_pp)
```

```{r peakpicking-msdata-show2, }
# parameters are added to each analysis after running peak picking
summary(getSettings(sp2_pp_2, where = "analyses", analyses = 1))
```

```{r peakpicking-msdata-show-2}
sp2_pp_2
```

```{r peakpicking-msanalysis-run, results='hide', message=FALSE}
# running peak picking for an msAnalysis object (settings were already added above)
a2 <- peakPicking(a2)
```

```{r peakpicking-msanalysis-show}
# msAnalysis with peaks
a2
```

### Using multiple settings

As aforementioned, different settings for the same processing step can exist in a *msData*. Below we add different settings for the influent samples, as an example. The use case for such functionality can be connected to optimization of processing steps, for example.

```{r peakpicking-multiple-settings}
sp2_pp_3 <- sp2

# Settings for using openms instead of xcms
settings_pp_2 <- createSettings(
  call = "peakPicking",
  algorithm = "openms",
  parameters = list(
    noiseThrInt = 500,
    chromSNR = 10,
    chromFWHM = 10,
    mzPPM = 15,
    reEstimateMTSD = TRUE,
    traceTermCriterion = "sample_rate",
    traceTermOutliers = 5,
    minSampleRate = 1,
    minTraceLength = 3,
    maxTraceLength = -1,
    widthFiltering = "fixed",
    minFWHM = 2,
    maxFWHM = 40,
    traceSNRFiltering = FALSE
  )
)

sp2_pp_3 <- addSettings(sp2_pp_3, settings = settings_pp, where = "analyses")

# adding different settings to analysis 4 to 6
sp2_pp_3 <- addSettings(sp2_pp_3, settings = settings_pp_2, where = "analyses", analyses = 7:12)

# the algorithm of the influent samples is different
sapply(analysisNames(sp2_pp_3), function(x) getAlgorithm(getSettings(sp2_pp_3, where = "analyses", analyses = x)[[1]]))
```

```{r peakpicking-multiple-run, results='hide', message=FALSE}
#running peak picking
sp2_pp_3 <- peakPicking(sp2_pp_3)
```

```{r peakpicking-multiple-show}
# as the peak parameters with "openms" as algorithm were more stringent, the influent analyses have less peaks when compared to "xcms3" 
sp2_pp_3
```

### Export and Import settings

The *settings* object can be exported as a JSON or rds file and then imported for other sets where the same parameter settings are to be applied. The methods `exportSettings` and `importSettings` are used, as shown below.

Export settings:

```{r export-settings}

#export settings as rds
exportSettings(settings_pp, name = "settings_pp", format = "rds", path = getwd())

#export settings as JSON
exportSettings(settings_pp_2, name = "settings_pp_2", format = "json", path = getwd())
```

Import settings:

```{r import-settings}
#import settings as rds
settings_pp_imported <- importSettings(file = paste0(getwd(), "/settings_pp.rds"))
all.equal(settings_pp, settings_pp_imported)

#import settings as JSON
settings_pp_2_imported <- importSettings(file = paste0(getwd(), "/settings_pp_2.json"))
all.equal(settings_pp_2, settings_pp_2_imported)
```

### Inspecting peaks

The access and visualization of peaks uses the calculated/estimated time and *m/z* dimensions as well as the monoisotopic mass for collecting and plotting the correspondent mass traces. Examples are shown below to extract and plot peaks from both *msData* and *msAnalysis*.

For a *msData* object:

```{r inspecting-peaks-msdata, eval=FALSE}
#access to peaks by mz in analyses 4 and 10 of msData based on built targets, as used for extracting EICs
peaks(sp2_pp, analyses = c(4, 10), mz = mz1[1], rt = rt1[1], ppm = 10, sec = 30)
```

```{r inspecting-peaks-msdata-table, echo=FALSE}
peaks(sp2_pp[c(4, 10)], mz = mz1[1], rt = rt1[1], ppm = 10, sec = 30)
```

```{r inspecting-peaks-msdata-both, eval=FALSE}
#access peaks for Diuron-d6 in both positive and negative influent samples using monoisotopic mass instead of mz
peaks(sp2_pp,
      analyses = grep("influent", analysisNames(sp2_pp)),
      mass = diuron_d6, ppm = 10, sec = 15)
```

```{r inspecting-peaks-msdata-both-table, echo=FALSE}
peaks(sp2_pp,
      analyses = grep("influent", analysisNames(sp2_pp)),
      mass = diuron_d6, ppm = 10, sec = 15)
```

```{r inspecting-peaks-msdata-plot}
#plotting peaks in msData
plotPeaks(sp2_pp, mass = diuron_d6, interactive = TRUE, colorBy = "analyses")
```

```{r inspecting-peaks-msdata-map}
#map plot for peak time and m/z dimensions for msData (the shading represents the peak m/z and time deviations)
mapPeaks(sp2_pp, mz = targets4[2, ], colorBy = "replicates", xlim = 30, ylim = 0.001)

#Note, peaks appear for the negative samples but clearly they are not the corresponding peaks of the given target for Diuron-d6. For instance, the visual evaluation with mapPeaks is useful to define/optimize settings for grouping peaks across samples.
```

For a *msAnalysis* object:

```{r inspecting-peaks-msAnalysis}
#access to peak in msAnalysis
peaks(a2, mz = targets4)
```

```{r inspecting-peaks-msAnalysis-plot}
#plotting peaks from msAnalysis
plotPeaks(a2, mz = targets4, interactive = FALSE)
```

```{r inspecting-peaks-msAnalysis-map}
#map plot for peak time and m/z dimensions for msAnalysis
mapPeaks(a2, mz = targets4[1, ], xlim = 30, ylim = 0.001)
```

## Alingment and grouping

After peak picking, a common following step is to group the peaks across analyses. A retention time alignment can be applied to correct elution deviations across analyses. The result of peak grouping and alignment is added to the *msFeatures* S4 class object already present in the *msData*.

### Grouping settings

The processing parameters for grouping and alignment are added similarly to the processing settings for peak picking but the argument `where` is set to "features", as shown below. The settings are added to the slot settings of the *msFeatures* object and can be obtained by the method `getSettings`, as shown below. Note that, for grouping positive and negative analyses, the retention time alignment would not work. Alignment can be applied only with either positive or negative analysis as shown below in \@ref(alignment-results).

```{r creating-grouping-parameters}

# with xcms3
settings_pg_xcms <- createSettings(
  call = "peakGrouping",
  algorithm = "xcms3",
  parameters = list(
    groupParam = xcms::PeakDensityParam(
      sampleGroups = "holder",
      bw = 10,
      minFraction = 0.6,
      minSamples = 2,
      binSize = 0.008,
      maxFeatures = 100
    )
  )
)

# with openms
settings_pg_openms <- createSettings(
  call = "peakGrouping",
  algorithm = "openms",
  parameters = list(
    rtalign = FALSE,
    QT = FALSE,
    maxAlignRT = 10,
    maxAlignMZ = 0.01,
    maxGroupRT = 4,
    maxGroupMZ = 0.01,
    extraOptsRT = NULL,
    extraOptsGroup = NULL
  )
)

# add settings for peakGrouping to slot features in the msData
sp2_pp <- addSettings(sp2_pp, settings = settings_pg_openms, where = "features")

# get the settings applied/to be apliied for peakGrouping
getSettings(sp2_pp, where = "features")
```

### Processing grouping and alignment

The data processing for grouping and alignment follows the same principle as peak picking. Either the settings are added as arguments or the added parameters in the *msFeatures* object are used in the function call. Below, both cases are demonstrated below.

```{r processing-grouping-run, results='hide', message=FALSE}
#using the added parameter settings
sp2_pg <- peakGrouping(object = sp2_pp)
```

```{r processing-grouping-show}
#features added to msData
sp2_pg
```

```{r processing_grouping-run2, results='hide', message=FALSE}
#adding the parameter settings as arguments
sp2_pg_2 <- peakGrouping(sp2_pp, settings = settings_pg_xcms)
```

```{r processing-grouping-show2}
#features added to msData
sp2_pg_2
```

### msFeatures class

The structure of the *msFeatures* is shown below. The slot `analyses` is the `data.table` as obtained by the `analysisTable`, containing basic information about the analyses, such as file full path, replicate and associated blank replicates. The intensity slot contains the intensity of the feature in each analysis (i.e., corresponding peak intensity in each analysis). The slot metadata holds additional information about each feature, such as average *m/z*/ neutral mass, retention time and number of corresponding peaks. The slot settings has the list of settings used to build/process features, such as `peakGrouping` and `filterFeatures`.

```{r msfeatures-class}
str(sp2_pg@features, max.level = 2)
#Note, accessing directly the features slot in a given msData object is not recommended.
#Access to features should be done with the applied method, as shown below in inspecting features.
```

### Inspecting features

Features can be accessed via the method `features` applied to a *msData* object. The argument `complete` can be set to `TRUE` for a complete list of features information. Also, the argument `average` can be set to `FALSE` for returning the intensity of the feature in each analysis than the average for each analysis replicate.

```{r inspecting-features, message=FALSE, warning=FALSE}
#getter for feature intensities correspondent to the mass of Diuron in each sample by setting average to false
features(sp2_pg, mass = diuron_d6, ppm = 10, sec = 20, average = FALSE)

#getter for features intensities and intensity deviations using m/z; note that mass of targets m/z values will be calculated according to present adducts
features(sp2_pg, mz = targets4)

#getter for all the feature metadata by setting complete to TRUE
t(features(sp2_pg, mass = carbamazepin_d10, ppm = 10, complete = TRUE, average = TRUE))

#plotting features
plotFeatures(sp2_pg,
  mass = rbind(diuron_d6, carbamazepin_d10),
  ppm = 10, sec = 10, colorBy = "targets",
  interactive = FALSE)

#plotting features for replicates and interactive
plotFeatures(sp2_pg,
  mass = rbind(diuron_d6, carbamazepin_d10),
  ppm = 10, sec = 10, colorBy = "replicates",
  interactive = TRUE)

#plot the individual peaks in features and for each analysis shows the time deviation.
plotFeaturePeaks(sp2_pg, mz = targets4)

#plotFeaturePeaks(sp2_pg, mass = rbind(diuron_d6, carbamazepin_d10))
```

### Alignment results

The alignment results can be inspected with the `plotAlignment` function. However, the time adjustment results are only available when using the algorithm "xcms3" for alignment with polarity positive or negative. Mixed positive and negative polarities does not support rt alignment. Below peaks from samples in positive mode only are grouped, including retention time alignment. 

```{r grouping-msdata-only-positive, message=FALSE, warning=FALSE}

# subset of msData with only positive analyses
sp2_pg_3 <- sp2_pp[c(4:6, 10:12)]

# grouping settings with alignment scheduled 
settings_pg_xcms_2 <- list(
  rtalign = TRUE,
  loadRawData = TRUE,
  groupParam = xcms::PeakDensityParam(
    sampleGroups = "holder",
    bw = 3,
    minFraction = 0.6,
    minSamples = 2,
    binSize = 0.008,
    maxFeatures = 100),
  preGroupParam = xcms::PeakDensityParam(
    sampleGroups = "holder",
    bw = 5,
    minFraction = 1,
    minSamples = 3,
    binSize = 0.008,
    maxFeatures = 100),
  retAlignParam = xcms::PeakGroupsParam(
    minFraction = 1,
    extraPeaks = 0,
    smooth = "loess",
    span = 0.3,
    family = "gaussian")
)

settings_pg_xcms_2 <- createSettings(
  call = "peakGrouping",
  algorithm = "xcms3",
  parameters = settings_pg_xcms_2
)

sp2_pg_3 <- peakGrouping(sp2_pg_3, settings = settings_pg_xcms_2)
```

```{r plot-alignment}
plotAlignment(sp2_pg_3)
```


## Recursive integration

As peak picking can result in false negatives and to ensure that false positives are less likely, a recursive integration is often performed for filling missing peaks in a given feature. The recursive integration consists of extracting the mass traces in the feature region from analyses not represented, returning the hypothetical peak intensity. The exact collection of mass traces and calculation of the peak intensity (or height) is dependent on the algorithm applied. Below, an example of the recursive integration workflow using the function [fillChromPeaks](https://rdrr.io/bioc/xcms/man/fillChromPeaks.html) from the package [xcms](https://bioconductor.org/packages/release/bioc/html/xcms.html) is shown. The function `peakFilling` is used for recursive integration and a *settings* S4 class object is given to define the algorithm and respective parameters. A *settings* object can be obtained with `fillingSettingsDefaultXCMS` for a default *ChromPeakAreaParam* from xcms. Note that the `peakFilling` settings are added to the settings slot of the *msFeatures* object.

```{r recursive-integration-settings}
#default settings S4 class with ChromPeakAreaParam from xcms as parameter settings
settings_fl <- fillingSettingsDefaultXCMS()

settings_fl
```

```{r recursive-integration-run, results='hide', message=FALSE}
#filling peaks for msData
sp2_pg_3_fl <- peakFilling(sp2_pg_3, settings = settings_fl)
```

### Inspection of filled peaks

To inspect filled peaks, the function `plotFeaturePeaks` can be used as shown below. The white dots represent filled peaks, meaning that the intensity value was not obtained from peak picking. The recursive integration is relevant to further minimize false negative features by reinforce the presence of the feature in the relevant analyses but not in the blank analysis replicate. Also, on the other end, for reducing false positives by confirming the presence of the features at similar level in the blank replicate analysis, as shown below. The second feature, at 935 seconds, peaks were picked only for the influent but the blank has very similar level as confirmed by recursive integration, which most likely is related to peaks from noise. Applying filtering by blank subtraction further during the basic data processing workflow, would remove the irrelevant features, such as the example shown below.

`r # TODO find another example for filling results`

```{r recursive-integration-inspection}
# inspecting the filled peaks for a given mz and rt target
plotFeaturePeaks(sp2_pg_3_fl, mz = 441.1670, rt = 1097, ppm = 20, sec = 60)
```

## Annotation

Annotation of isotopes and adducts is crucial not only to prioritize the relevant features but also to deliver essential information for further identification, such as charge, isotopic pattern and adduct yield. Annotation in streamFind is applied through patRoon which uses the [CAMERA](https://www.bioconductor.org/packages/release/bioc/html/CAMERA.html) R package. Again, *msData* objects with both positive and negative analyses would not work for annotation. The results of annotation are stored as extra columns in the metadata slot of the *msFeatures* S4 class.

```{r creating-annotation-parameters, results='hide', message=FALSE}
#creating settings for using CAMERA
settings_an <- createSettings(
  call = "peakAnnotation",
  algorithm = "camera",
  parameters = list(
    ionization = NA_character_,
    onlyIsotopes = FALSE,
    minSize = 1,
    relMinReplicates = 1,
    extraOpts = list(
      sigma = 6,
      perfwhm = 0.35,
      cor_eic_th = 0.3,
      graphMethod = "hcs",
      pval = 0.05,
      calcCiS = TRUE,
      calcIso = TRUE,
      calcCaS = TRUE,
      maxcharge = 3,
      maxiso = 5,
      ppm = 15,
      mzabs = 0.008,
      rules =  data.table::fread(system.file("rules/primary_adducts_pos.csv", package = "CAMERA"), header = TRUE),
      multiplier = 3,
      max_peaks = 500,
      intval = "maxo"
    )
  )
)
```

```{r annotation-run, results='hide', message=FALSE}
sp2_pg_3_fl_an <- peakAnnotation(sp2_pg_3_fl, settings = settings_an)
```

### Inspection of annotation

The annotation can be inspected with the `annotation` S4 method for the *msData* object, as shown below. The method `plotAnnotation` can then be used to visualize the annotation of features, as shown below.

```{r annotation-results}
#isotopic and adduct features annotated with a given target mz and rt
annotation(sp2_pg_3_fl_an, mz = targets4[1, ], ppm = 20, rt = NULL, sec = 60, all = FALSE)

#plotting the annotation of each feature in a given target
plotAnnotation(sp2_pg_3_fl_an, mz = targets4, ppm = 20, rt = NULL, sec = 60, all = FALSE, colorBy = "isotopes")
```

## Filter data

Data filtration is crucial for proper prioritization of relevant peaks/features. In streamFind, two levels of data filtration is implemented: (1) data sub-setting (permanent) and (2) filter processing steps for peaks and/or features (both are tagged as filtered but not removed).

### Sub-seeting with '['

The first is based on data sub-setting using the method `[` and is permanent, meaning that the peaks/features are completely removed from the *msAnalysis*/*msFeatures*. An example is shown below for data filtration using the `[` method for different classes.

```{r filter-subsetting}
#sub-setting the msData class on analyses (the 3 first)
sp2_pg[1:3, ]

#sub-setting the msData class on analyses and features (the 3 last analyses and features annotated with a target)
target_s <- annotation(sp2_pg_3_fl_an, mz = targets4[1, ], ppm = 20, rt = NULL, sec = 5, all = FALSE)
sp2_pg_3_fl_an[4:6, target_s$id]

#sub-seeting the msData class on analyses ([i, ]) and features ([, j]) by index
sp2_pg_3_fl_an[1:2, 1:5]

#sub-setting an msAnalysis class on the first 5 peaks
a2[1:5]
```

### Filter functions

The second method uses filter functions (i.e., `filterPeaks` and `filterFeatures`) and is conservative, meaning that the data is conserved but tagged as filtered (i.e., the *filtered* column is changed to `TRUE` and the respective filter tag is added to column *filter*, as shown below). Both filtered peaks and features can be permanently removed by running the methods `removeFilteredPeaks` or `removeFilteredFeatures`, respectively. Note that, removing features permanently does not remove filtered peaks but peaks not represented by features are filtered with "grouping" tag. When removing peaks, the features left without peaks representation are removed as well. Also, the methods `peaks` and `features` have the argument *filtered* to return filtered peaks/features. The default for the *filtered* argument is `TRUE`, meaning that filtered peaks/features are returned by default for methods `peaks` and `features`. Simmilarly, to peakPicking, peak Grouping, etc., the filter methods use a *msSettings* S4 class to store the filtering parameters. Also, the filtering *msSettings* object when applied is stored in the parameters section opf the respective class (i.e., `filterPeaks` settings are stored in the *msAnalysis* and `filterFeatures` settings are stored in the *msFeatures*).

#### Filter features

```{r filter-features}

filters <- list(
  minIntensity = 5000,
  blankThreshold = 3,
  maxReplicateIntensityDeviation = 30,
  minReplicateAbundance = 3,
  excludeIsotopes = TRUE,
  excludeAdducts = TRUE
)

settings_filFeat <- createSettings(
  call = "filterFeatures",
  algorithm = "filter",
  parameters = filters
)

sp2_pg_3_fl_an_filFeat <- addSettings(sp2_pg_3_fl_an, where = "features", settings = settings_filFeat)

sp2_pg_3_fl_an_filFeat <- filterFeatures(sp2_pg_3_fl_an_filFeat)

#number of features not filtered
nrow(features(sp2_pg_3_fl_an, filtered = FALSE))

#number of features not filtered after applying the filters
nrow(features(sp2_pg_3_fl_an_filFeat, filtered = FALSE))

#remove permanently all filtered features from the msData object
sp2_pg_3_fl_an_filFeat_rem <- removeFilteredFeatures(sp2_pg_3_fl_an_filFeat, which =  "all")

sp2_pg_3_fl_an_filFeat_rem
```

#### Filter peaks

`r # TODO add filterPeaks option to msData and msAnalysis`

```{r filter-peaks}





```

## Quality

The quality of the data is crucial to improve the prioritization of peaks/features and the relevance of the results. In streamFind, two functions are available to calculate quality of peaks/features: `calculateSNR` and `calculateMetaClean` to estimate the signal-to-noise ration and several fitting parameters of each peak/feature, respectively. The latter is based on the [MetaClean](https://rdrr.io/cran/MetaClean/) R package and is applied via patRoon. It is important to emphasize that peaks/features should be filtered with basic filters (e.g., blank subtraction, minimum intensity, etc.) before applying quality calculation has the computational demand for large number of peaks/features is high.

`r # TODO implement MetaClean qualita evaluation``

```{r quality-sn}
sp2_pg <- calculateSNR(sp2_pg, targetsID = features(sp2_pg)[["id"]][1:2])

features(sp2_pg, complete = TRUE)[1:2, ]
```

# MSn

Often MS acquisition includes operation in tandem mode, where fragmentation spectra (i.e., MSn, where n is the level of fragmentation) are acquired. The most common fragmentation data is MS/MS or MS2 either acquired via data dependent or independent acquisition.

## Access and plot MS2

The method `MS2s` can be used to collect MS2 data from given targets, following the same principle as `makeTargets` within `EICs`. Similarly, `plotMS2s` can be used to access and directly plot MS2 data from targets, as shown below.

```{r extract-ms2}
#head of MS2 data for target 1 in a msAnalysis object
head(MS2s(a1, mzClust = 0.01, isolationWindow = 1, mz = targets4[1, ]))

#plotting the MS2 data of the first target in a msAnalysis object
plotMS2s(a1, mzClust = 0.01, isolationWindow = 1, mz = targets4[1, ])

#most intense MS2 data traces for both targets in a msData object
ms2_data <- MS2s(sp1, mzClust = 0.01, isolationWindow = 1, mz = targets4)
ms2_data <- ms2_data[order(intensity, decreasing = TRUE), ]
head(ms2_data)

#plotting the MS2 data of the first target in a msAnalysis object
plotMS2s(sp1, mzClust = 0.01, isolationWindow = 1, mz = targets4,
         interactive = TRUE, colorBy = "targets")
```

## MS2 for features/peaks

`# TODO create function for collecting MS2 data for peaks/features`

# patRoon interchangeability

`# TODO add as.msData and as.msAnalysis functions`

# Workflows

TO be implemented

# Nomenclature

The nomenclature listed below is consistently applied throughout the objects and arguments of functionalities in the streamFind package. Other less relevant terms are used but not listed. For further information please consult the specific documentation of each object or functionality when required using the `?x` method, where x is the name of the S4 class, S4 method or function.

-   *streamSet* refers to the broader S4 class applied in the streamFind package and holds basic information for an analysis set, see \@ref(streamset-class);
-   *msData* refers to the S4 subclass of *streamSet* when MS analyses (i.e., MS files) are added to the set, see \@ref(msdata-class);
-   *msAnalysis* refers to the S4 class of the object generated for each MS file added to the *msData* object in the slot "analyses";
-   `setInfo` is the method to obtain the basic information (i.e., title, date and path) of a *streamSet* object;
-   `analyses` is the name of the slot holding the analyses (as list) and is also a method to get the analysis names in the *streamSet*;
-   `replicate` is the name of an analysis replicate group and the method to get the replicate names;
-   `blank` is the name of a blank analysis replicate group to be used for blank (blind) subtraction and the method to get blank replicate names;
-   **traces** corresponds to a raw data signal (e.g., mass trace in MS data) obtained from a given analysis file;
-   `spectra` for MS analyses is the method to get a table with a spectrum for each cycle time (i.e., retention time);
-   **EIC** is an extracted ion chromatogram (retention time vs intensity) and can be obtained with the method `EICs`;
-   **TIC** is a total ion chromatograms (retention time vs intensity) and can be obtained with the method `TICs`;
-   **XIC** is a three dimensional ion chromatogram (*m/z* vs retention time vs intensity) and can be obtained with the method `XICs`;
-   **peak** corresponds to a cluster of traces (e.g., integrated chromatographic MS peak) within an analysis file and can be accessed with the method `peaks`;
-   **feature** corresponds to a group of corresponding peaks across analysis files/analyses and can be accessed with the method `features`;
-   **MS2** corresponds to second order fragmentation data as acquired in tandem MS or MS/MS mode and can be accessed with the method `MS2s`.

(...)

# Parallel processing

To be added

# Miscellaneous

```{r democode, echo=FALSE, eval=FALSE, include=FALSE}

# param_g <- list(
#   rtalign = TRUE,
#   loadRawData = TRUE,
#   groupParam = xcms::PeakDensityParam(
#     sampleGroups = "holder",
#     bw = 3,
#     minFraction = 0.6,
#     minSamples = 2,
#     binSize = 0.008,
#     maxFeatures = 100),
#   preGroupParam = xcms::PeakDensityParam(
#     sampleGroups = "holder",
#     bw = 5,
#     minFraction = 1,
#     minSamples = 3,
#     binSize = 0.008,
#     maxFeatures = 100),
#   retAlignParam = xcms::PeakGroupsParam(
#     minFraction = 1,
#     extraPeaks = 0,
#     smooth = "loess",
#     span = 0.3,
#     family = "gaussian")
# )

# knitr::kable(pks_1, caption = "Peaks data.table from msData using the peaks S4 method.") %>%
#   kable_styling(font_size = 11, bootstrap_options = c("striped", "hover", "responsive"), fixed_thead = TRUE) %>%
#   scroll_box(width = "100%", height = "600px")


# object <- sp2_pg_fl
# settings <- annotationSettingsDefaultCAMERA()
# settings <- annotationSettingsDefaultRAMClustR()
# object <- addParameters(object, where = "features", settings)
# 
# 
# 
# findFGroup(comp, "M239_R936_497")
# as.data.frame(comp[702, ])
# 
# mapPeaks(object, mz = data.table(mzmin = 208, mzmax = 220, rtmin = 635, rtmax = 645))
# 
# plotXICs(object, analyses = 1:2, mz = 262.0450, ppm = 40, rt = 936, sec = 120)
# 
# View(features(object, mz = 441.1670, ppm = 20, rt = 916, sec = 10, complete = TRUE))
# View(features(object, complete = TRUE)[monoiso %in% "m441.168_d0.7_r916_t6_f3225", ])

# trimSpectraFilesMZR(files = choose.files(), rtr = c(500, 1000), mzr = c(200, 800), onlyMS1 = TRUE)
# 
# mz_05 <- data.frame(
#   retmin = c(809, 907), retmax = c(869, 967),
#   mzmin = c(247.1626, 239.0604), mzmax = c(247.1676, 239.0652)
# )
# 
# #test <- patRoon::getEICs(msa_1@file, mz_05)
# 
# test <- extractEICs(object, mz = targets4)
# test_xic <- extractXICs(object, mz = targets4)

# setInfo(msd)
# path(msd)
# filePaths(msd)
# analysisNames(msd)
# replicateNames(msd)
# blankReplicateNames(msd)
# polarities(msd)
# analysisInfo(msd)
# 
# replicateNames(msd) <- c("s1", "s2")
# blankReplicateNames(msd) <- c(NA_character_, "s2")
# 
# validObject(msd)
# 
# filePaths(msa_1)
# analysisNames(msa_1)
# replicateNames(msa_1)
# blankReplicateNames(msa_1)
# polarities(msa_1)
# 
# replicateNames(msa_1) <- "s1"
# blankReplicateNames(msa_1) <- "s2"

# object <- msd
# 
# loadMS1 <- function(object, analysis = NULL, what = "MS1") {
#   
#   
#   test <- RaMS::grabMSdata(filePaths(object)[1], grab_what = "MS1", rtrange = c(min(rt_02), max(rt_02)))
#   
#   ms2 <- test$MS2
#   
#   ms2[premz > 273 & premz < 274, ]
#   
#   View(ms2)
# 
# }

```

------------------------------------------------------------------------

Insitut für Energie- und Umwelttechnik e.V. (IUTA)\
<br> For further questions, please contact Ricardo Cunha ([cunha\@iuta.de](cunha@iuta.de)).
